#!/usr/libexec/flua
--
-- Copyright (c) 2016-2025 Ryan Moeller
--
-- SPDX-License-Identifier: ISC
--

--
-- Use with inetd:
-- http  stream  tcp  nowait  root  /path/to/lua-httpd/samples/websockets/server.flua  websockets-server
--

local posix <const> = require("posix")

local basedir <const> = posix.libgen.dirname(arg[0])

local function path(...)
    return table.concat(table.pack(...), "/")
end

local function relpath(...)
    return path(basedir, ...)
end

package.path = table.concat({
    relpath("../../?.lua"),             -- httpd.lua
    relpath("../contrib/?.lua"),        -- samples/contrib/template.lua
    relpath("?.lua"),                   -- samples/websockets/*.lua
    package.path
}, ";")

local logdir <const> = "/var/log"
local logfile <const> = path(logdir, "wsdemo.log")
local errfile <const> = path(logdir, "wsdemo-errors.log")

require("fileno")
local STDIN_FILENO <const> = 0
local STDOUT_FILENO <const> = 1
local STDERR_FILENO <const> = 2

-- inetd by default uses the same socket for stderr as it does for stdin/stdout.
-- Setting io.stderr does not actually replace stderr of the process.  We have
-- to do this the hard way.
do
    local f <close> = io.open(errfile, "a+")
    f:setvbuf("no")
    -- FIXME: assert is bogus here
    assert(posix.unistd.dup2(f:fileno(), STDERR_FILENO) == STDERR_FILENO)
end

local httpd <const> = require("httpd")
local template <const> = require("template")
local ucl <const> = require("ucl")

local server <const> = httpd.create_server(httpd.INFO, logfile)
local log <const> = server.log

server:add_route("GET", "^/$", function(request)
    local headers <const> = {
        ["Content-Type"] = "text/html; charset=utf-8",
        ["X-Content-Type-Options"] = "nosniff",
    }
    local body <const> = template.process([[
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>WebSocket Demo</title>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
          <link rel="stylesheet" href="https://unpkg.com/bulmaswatch/{{theme}}/bulmaswatch.min.css">
        </head>
        <body>
          <div class="columns is-centered">
            <div class="column is-narrow">
              <h1 class="title"><span class="has-text-danger">WebSocket</span> Demo</h1>
              <section class="is-hidden py-4" id="boot-envs-table">
                <h2 class="subtitle">Boot Environments</h2>
                <table class="table">
                  <thead>
                    <tr>
                      <th>BE</th>
                      <th>Active</th>
                      <th>Used</th>
                      <th>Creation</th>
                      <th>Destroy</th>
                    </tr>
                  </thead>
                </table>
              </section>
              <section class="is-hidden py-4" id="snapshots-table">
                <h2 class="subtitle">Downloaded Snapshot Builds</h2>
                <table class="table">
                  <thead>
                    <tr>
                      <th>Build Date</th>
                      <th>Revision</th>
                      <th>Path</th>
                      <th>BE?</th>
                      <th>Delete</th>
                    </tr>
                  </thead>
                </table>
              </section>
              <section class="is-hidden is-danger py-4" id="latest-error">
                <h2 class="subtitle">Updates</h2>
                <p class="notification is-danger"></p>
              </section>
              <section class="is-hidden py-4" id="no-updates">
                <h2 class="subtitle">Updates</h2>
                <p>The latest snapshot is installed.</p>
              </section>
              <section class="is-hidden py-4" id="update-available">
                <h2 class="subtitle">Updates</h2>
                <p><em>A new snapshot is available!</em></p>
                <form action="javascript:update()">
                  <div class="field">
                    <label class="label"></label>
                    <div class="control">
                      <button class="button is-primary" type="submit" name="latest">
                        Create Updated Boot Environment
                      </button>
                    </div>
                  </div>
                </form>
              </section>
              <section class="is-hidden py-4" id="updating">
                <h2 class="subtitle">Updating...</h2>
                <progress class="progress" value="0" max="100">0%</progress>
                <p>Starting download</p>
                <article class="message is-danger is-hidden" id="updating-error">
                    <div class="message-header">
                      <p>Error <em></em></p>
                    </div>
                    <div class="message-body"></div>
                </article>
              </section>
              <script src="/scripts/ws.js"></script>
            </div>
          </div>
        </body>
      </html>
    ]], { theme="darkly" })
    return { headers=headers, status=200, reason="ok", body=body }
end)

server:add_route("GET", "^/scripts/[^/]+%.js$", function(request)
    local lfs <const> = require("lfs")
    local sendfile <const> = require("sendfile")

    local p <const> = relpath(request.path)
    local st <const>, err <const>, code <const> = lfs.attributes(p)
    if not st then
        log:info(("not found: %s (%d)"):format(err, code))
        return { status=404, reason="Not Found", body="not found" }
    end
    if st.mode ~= "file" then
        log:info("request forbidden")
        return { status=403, reason="Forbidden", body="permission denied" }
    end
    local headers <const> = {
        ["Content-Length"] = st.size,
        ["Content-Type"] = "text/javascript; charset=utf-8",
        ["X-Content-Type-Options"] = "nosniff",
    }
    local f <const>, err <const>, code <const> = io.open(p, "r")
    if not f then
        log:error(("open failed: %s (%d)"):format(err, code))
        if code == 1 then -- EPERM
            return { status=403, reason="Forbidden", body="permission denied" }
        elseif code == 2 then -- ENOENT
            return { status=404, reason="Not Found", body="not found" }
        else
            return { status=500, reason="Internal Server Error", body="internal server error" }
        end
    end
    local function body(conn)
        local output <const> = conn.output
        -- The socket is not non-blocking, so we expect a full send.
        local sbytes <const> = assert(sendfile(f:fileno(), output:fileno(), 0, 0))
        assert(sbytes == st.size)
        f:close()
    end
    return { headers=headers, status=200, reason="ok", body=body }
end)

server:add_route("GET", "^/ws$", function(request)
    local ws <const> = require("websocket")

    local connection_header <const> = request.headers["connection"]
    local upgrade_header <const> = request.headers["upgrade"]
    local key_header <const> = request.headers["sec-websocket-key"]
    local version_header <const> = request.headers["sec-websocket-version"]
    local connection_upgrade <const> =
        connection_header and connection_header:contains_value("Upgrade")
    local upgrade <const> = upgrade_header and upgrade_header:concat()
    local key <const> = key_header and key_header:concat()
    local version <const> = version_header and version_header:concat()
    if not connection_upgrade or upgrade ~= "websocket" or
        not key or version ~= "13" then
        log:info("bad request")
        return { status=400, reason="Bad Request", body="can't do that" }
    end
    local headers <const> = {
        ["Connection"] = "Upgrade",
        ["Upgrade"] = upgrade,
        ["Sec-WebSocket-Accept"] = ws.accept(key),
    }
    local function ws_main(conn)
        local bectl <const> = require("bectl")
        local beup <const> = require("beup")
        local kqueue <const> = require("kqueue")

        beup.logfile = logfile

        local kq <const> = assert(kqueue.kqueue())
        local threads <const> = {} -- XXX: coroutines have to outlive events
        local changelist

        -- Approximately line-buffered pipe reader and child waiter.
        local function handle_child(pipe, pid, ondata, onexit)
            local thread <const> = coroutine.create(function(event)
                local buf = ""
                repeat
                    local data <const> =
                        assert(posix.unistd.read(pipe, event.data))
                    local eof <const> = event.flags & kqueue.EV_EOF ~= 0
                    buf = buf .. data
                    -- Approximately line-buffered is good enough.
                    if buf:find("\n") or (eof and buf ~= "") then
                        ondata(buf)
                        buf = ""
                    end
                    if not eof then
                        event = coroutine.yield()
                    end
                until eof
                assert(posix.unistd.close(pipe))
                local _, exit_type <const>, exit_code <const> =
                    assert(posix.sys.wait.wait(pid))
                if onexit then
                    onexit(exit_type, exit_code)
                end
            end)
            -- Save the thread in a scope that survives the kqueue.
            threads[thread] = true
            -- Add the event to the kqueue.
            changelist = changelist or {}
            table.insert(changelist, {
                ident = pipe,
                filter = kqueue.EVFILT_READ,
                flags = kqueue.EV_ADD,
                udata = thread
            })
        end

        local function ws_send(t)
            ws.send(conn, ucl.to_json(t, true), ws.WS_OP_TEXT, ws.WS_FL_FIN)
        end

        local CMD_STATUS <const> = "status"
        local CMD_BE_LIST <const> = "be_list"
        local CMD_SNAP_LIST <const> = "snap_list"
        local CMD_LATEST <const> = "latest"
        local CMD_UPDATE <const> = "update"
        local CMD_BE_DESTROY <const> = "be_destroy"
        local CMD_SNAP_DELETE <const> = "snap_delete"
        local handlers <const> = {
            [CMD_STATUS] = function(msg)
                ws_send{status="ok"}
                return true
            end,
            [CMD_BE_LIST] = function(msg)
                ws_send{command=msg.command, data=bectl.list()}
                return true
            end,
            [CMD_SNAP_LIST] = function(msg)
                ws_send{command=msg.command, data=beup.snap_list()}
                return true
            end,
            [CMD_LATEST] = function(msg)
                -- This can take a while since it has to hit the Internet.
                -- Do it in a child process to avoid blocking the event loop.
                local r <const>, w <const> = assert(posix.unistd.pipe())
                local pid <const> = assert(posix.unistd.fork())
                if pid == 0 then
                    assert(posix.unistd.close(r))
                    assert(posix.unistd.close(STDIN_FILENO))
                    assert(posix.unistd.close(STDOUT_FILENO))
                    local data <const>, err <const> = beup.latest()
                    if not data then
                        assert(posix.unistd.write(w, err))
                        os.exit(1)
                    end
                    assert(posix.unistd.write(w, data))
                    os.exit(0)
                end
                assert(posix.unistd.close(w))
                -- We'll buffer the data until we have the full response.
                -- It should only take one read for this task, though.
                local buf = ""
                handle_child(r, pid,
                    function(data)
                        buf = buf .. data
                    end,
                    function(exit_type, exit_code)
                        assert(exit_type == "exited")
                        if exit_code == 0 then
                            ws_send{command=msg.command, data=buf}
                        else
                            ws_send{command=msg.command, data={error=buf}}
                        end
                    end
                )
                -- TODO: we could ack to trigger a spinner here
                return true
            end,
            [CMD_UPDATE] = function(msg)
                local r <const>, w <const> = assert(posix.unistd.pipe())
                local pid <const> = assert(posix.unistd.fork())
                if pid == 0 then
                    assert(posix.unistd.close(r))
                    assert(posix.unistd.close(STDIN_FILENO))
                    assert(posix.unistd.close(STDOUT_FILENO))
                    local function callback(progress, description)
                        local data <const> = ucl.to_json({
                            percent = progress * 100,
                            description = description,
                        }, true)
                        assert(posix.unistd.write(w, data .. "\n"))
                    end
                    assert(beup.update(callback))
                    os.exit(0)
                end
                assert(posix.unistd.close(w))
                handle_child(r, pid,
                    function(data)
                        local parser <const> = ucl.parser()
                        assert(parser:parse_string(data))
                        ws_send{command=msg.command, data=parser:get_object()}
                    end,
                    function(exit_type, exit_code)
                        assert(exit_type == "exited")
                        ws_send{command=msg.command, data={exit_code=exit_code}}
                    end
                )
                return true
            end,
            [CMD_BE_DESTROY] = function(msg)
                bectl.umount(msg.data.be)
                bectl.destroy(msg.data.be)
                return true
            end,
            [CMD_SNAP_DELETE] = function(msg)
                beup.snap_delete(msg.data.snap)
                return true
            end,
        }
        local ws_thread <const> = coroutine.create(function(event)
            local buf = ""
            repeat
                local payload <const>, opcode <const>, flags <const>,
                    consumed <const> = ws.receive(conn)
                if opcode == ws.WS_OP_CLOSE then
                    break
                elseif opcode == ws.WS_OP_PING then
                    ws.send(conn, payload, ws.WS_OP_PONG, ws.WS_FL_FIN)
                elseif opcode == ws.WS_OP_TEXT then
                    if payload then
                        buf = buf .. payload
                    end
                    if flags & ws.WS_FL_FIN ~= 0 then
                        local parser <const> = ucl.parser()
                        local ok <const>, err <const> = parser:parse_string(buf, "json")
                        buf = ""
                        if not ok then
                            log:error("parser error: ", err)
                            ws.send(conn, "internal server error", ws.WS_OP_CLOSE, ws.WS_FL_FIN)
                            break
                        end
                        local msg <const> = parser:get_object()
                        if not msg.command then
                            log:error("invalid message: ", ucl.to_json({msg}))
                            ws.send(conn, "invalid request", ws.WS_OP_CLOSE, ws.WS_FL_FIN)
                            break
                        end
                        local handler <const> = handlers[msg.command]
                        if not handler then
                            log:warn("unhandled message: ", ucl.to_json({msg}))
                        elseif not handler(msg) then
                            break
                        end
                    end
                else
                    log:warn("unhandled op: ", opcode)
                end
                -- Yield once we have consumed all the data for this event.
                if consumed >= event.data then
                    event = coroutine.yield()
                else
                    event.data = event.data - consumed
                end
            until false
        end)
        changelist = {
            {
                ident = conn.input:fileno(),
                filter = kqueue.EVFILT_READ,
                flags = kqueue.EV_ADD,
                udata = ws_thread
            }
        }
        while coroutine.status(ws_thread) ~= "dead" do
            local event <const> = assert(kq:kevent(changelist))
            changelist = nil
            local thread <const> = event.udata
            if thread then
                if (event.flags & kqueue.EV_ERROR) ~= 0 then
                    log:error("event error:", event.data)
                    log:debug(ucl.to_json(event))
                else
                    local ok <const>, err <const> =
                        coroutine.resume(thread, event)
                    if not ok then
                        log:error(err)
                        log:debug(ucl.to_json(event))
                    end
                end
                if coroutine.status(thread) == "dead" then
                    -- Delete the event for this thread.
                    event.flags = kqueue.EV_DELETE
                    event.udata = nil
                    changelist = changelist or {}
                    table.insert(changelist, event)
                    -- Now it is safe to GC the thread.
                    threads[thread] = nil
                    coroutine.close(thread)
                end
            end
        end
        for thread in pairs(threads) do
            coroutine.close(thread)
        end
        coroutine.close(ws_thread)
        log:trace("websocket closed")
        kq:close()
    end
    log:trace("switching connection to websocket protocol")
    return { headers=headers, status=101, reason="Switching Protocols", body=ws_main }
end)

server:run()

-- vim: set et sw=4:
