#!/usr/libexec/flua
--
-- Copyright (c) 2016-2025 Ryan Moeller
--
-- SPDX-License-Identifier: ISC
--

--
-- Use with inetd:
-- http  stream  tcp  nowait  www  /path/to/lua-httpd/samples/pkgbase/server.flua  pkgbase-builder
--

local srctop <const> = "/home/ryan/src"
local makeobjdirprefix <const> = "/storage/obj"
local kernconf <const> = "GENERIC-KTR" -- XXX: no kernel package variants

local posix <const> = require("posix")

local basedir <const> = posix.libgen.dirname(arg[0])

local function path(...)
    return table.concat(table.pack(...), "/")
end

local function relpath(...)
    return path(basedir, ...)
end

package.path = table.concat({
    relpath("../../?.lua"),             -- httpd.lua
    relpath("../contrib/?.lua"),        -- samples/contrib/template.lua
    relpath("../websockets/?.lua"),     -- samples/websockets/websocket.lua
    relpath("?.lua"),                   -- samples/pkgbase/*.lua
    package.path
}, ";")

local logdir <const> = "/var/log"
local logfile <const> = path(logdir, "pkgbase-builder.log")
local errfile <const> = path(logdir, "pkgbase-builder-errors.log")

require("fileno")
local STDIN_FILENO <const> = 0
local STDOUT_FILENO <const> = 1
local STDERR_FILENO <const> = 2

-- inetd by default uses the same socket for stderr as it does for stdin/stdout.
-- Setting io.stderr does not actually replace stderr of the process.  We have
-- to do this the hard way.
do
    local f <close> = io.open(errfile, "a+")
    f:setvbuf("no")
    -- FIXME: assert is bogus here
    assert(posix.unistd.dup2(f:fileno(), STDERR_FILENO) == STDERR_FILENO)
end

local httpd <const> = require("httpd")
local template <const> = require("template")
local ucl <const> = require("ucl")

local function tpl(name)
    return relpath("templates", ("%s.tpl.html"):format(name))
end

local server <const> = httpd.create_server(logfile)

server:add_route("GET", "^/$", function(request)
    local headers <const> = {
        ["Content-Type"] = "text/html; charset=utf-8",
        ["X-Content-Type-Options"] = "nosniff",
        ["Cache-Control"] = "no-store",
    }
    local body <const> = template.process(tpl"index", {
        srctop = srctop,
        makeobjdirprefix = makeobjdirprefix,
        kernconf = kernconf,
    })
    return { headers=headers, status=200, reason="ok", body=body }
end)

server:add_route("GET", "^/scripts/[^/]+$", function(request)
    local lfs <const> = require("lfs")
    local sendfile <const> = require("sendfile")

    local log = request.server.log
    local p <const> = relpath(request.path)
    local st <const>, err <const>, code <const> = lfs.attributes(p)
    if not st then
        log:info(("not found: %s (%d)"):format(err, code))
        return { status=404, reason="Not Found", body="not found" }
    end
    if st.mode ~= "file" then
        log:info("request forbidden")
        return { status=403, reason="Forbidden", body="permission denied" }
    end
    local headers <const> = {
        ["Content-Length"] = st.size,
        ["X-Content-Type-Options"] = "nosniff",
        ["Cache-Control"] = "no-store",
    }
    if p:match("%.js$") then
        headers["Content-Type"] = "text/javascript; charset=utf-8"
    elseif p:match("%.lua$") then
        headers["Content-Type"] = "text/x-lua; charset=utf-8"
    end
    local f <const>, err <const>, code <const> = io.open(p, "r")
    if not f then
        log:error(("open failed: %s (%d)"):format(err, code))
        if code == 1 then -- EPERM
            return { status=403, reason="Forbidden", body="permission denied" }
        elseif code == 2 then -- ENOENT
            return { status=404, reason="Not Found", body="not found" }
        else
            return { status=500, reason="Internal Server Error", body="internal server error" }
        end
    end
    local function body(output)
        -- The socket is not non-blocking, so we expect a full send.
        local sbytes <const> = assert(sendfile(f:fileno(), output:fileno(), 0, 0))
        assert(sbytes == st.size)
        f:close()
    end
    return { headers=headers, status=200, reason="ok", body=body }
end)

server:add_route("GET", "^/ws$", function(request)
    local ws <const> = require("websocket")

    local log = request.server.log
    local connection_header <const> = request.headers["connection"]
    local upgrade_header <const> = request.headers["upgrade"]
    local key_header <const> = request.headers["sec-websocket-key"]
    local version_header <const> = request.headers["sec-websocket-version"]
    local connection_upgrade <const> =
        connection_header and connection_header:contains_value("Upgrade")
    local upgrade <const> = upgrade_header and upgrade_header:concat()
    local key <const> = key_header and key_header:concat()
    local version <const> = version_header and version_header:concat()
    if not connection_upgrade or upgrade ~= "websocket" or
        not key or version ~= "13" then
        log:info("bad request")
        return { status=400, reason="Bad Request", body="can't do that" }
    end
    local headers <const> = {
        ["Connection"] = "Upgrade",
        ["Upgrade"] = upgrade,
        ["Sec-WebSocket-Accept"] = ws.accept(key),
    }
    local function ws_main(output)
        local builder <const> = require("builder")
        local git <const> = require("git")
        local kqueue <const> = require("kqueue")

        local repo <const> = git.repo(srctop)

        local kq <const> = assert(kqueue.kqueue())
        local threads <const> = {} -- XXX: coroutines have to outlive events
        local changelist

        -- Approximately line-buffered pipe reader and child waiter.
        local function handle_child(pipe, pid, ondata, onexit)
            local thread <const> = coroutine.create(function(event)
                local buf = ""
                repeat
                    local data <const> =
                        assert(posix.unistd.read(pipe, event.data))
                    local eof <const> = event.flags & kqueue.EV_EOF ~= 0
                    buf = buf .. data
                    -- Approximately line-buffered is good enough.
                    if buf:find("\n") or (eof and buf ~= "") then
                        ondata(buf)
                        buf = ""
                    end
                    if not eof then
                        event = coroutine.yield()
                    end
                until eof
                -- kqueue(2):
                --   Events which are attached to file descriptors are
                --   automatically deleted on the last close of the
                --   descriptor.
                assert(posix.unistd.close(pipe))
                -- Now it is safe to trash the thread.
                threads[coroutine.running()] = nil
                local _, exit_type <const>, exit_code <const> =
                    assert(posix.sys.wait.wait(pid))
                if onexit then
                    onexit(exit_type, exit_code)
                end
            end)
            -- Save the thread in a scope that survives the kqueue.
            threads[thread] = true
            -- Add the event to the kqueue.
            if not changelist then
                changelist = {}
            end
            table.insert(changelist, {
                ident = pipe,
                filter = kqueue.EVFILT_READ,
                flags = kqueue.EV_ADD,
                fflags = 0,
                data = 0,
                udata = thread
            })
        end

        local function ws_send(t)
            ws.send(output, ucl.to_json(t, true), ws.WS_OP_TEXT, ws.WS_FL_FIN)
        end

        require("scripts.wsproto") -- cool, shared client+server code!
        local handlers <const> = {
            [CMD_WORKTREE_LIST] = function(msg)
                ws_send{command=msg.command, worktrees=repo:worktree_list(),
                    upstreams=repo:upstreams()}
                return true
            end,
            [CMD_WORKTREE_PULL] = function(msg)
                local worktree <const> = git.repo(msg.data)
                local pipe <const>, pid <const> = worktree:pull()
                handle_child(pipe, pid,
                    function(buf)
                        ws_send{command=msg.command, output=buf}
                    end,
                    function(exit_type, exit_code)
                        assert(exit_type == "exited")
                        ws_send{command=msg.command, exit_code=exit_code}
                        if exit_code == 0 then
                            ws_send{command=CMD_WORKTREE_LIST,
                                worktrees=repo:worktree_list(),
                                upstreams=repo:upstreams()}
                        end
                    end
                )
                return true
            end,
            [CMD_REPO_LIST] = function(msg)
                local w <const> = msg.data
                local b <const> = builder.new(w, makeobjdirprefix, kernconf)
                ws_send{command=msg.command, worktree=w, repo=b:repo_list()}
                return true
            end,
            [CMD_REPO_BUILD] = function(msg)
                local w <const> = msg.data
                local b <const> = builder.new(w, makeobjdirprefix, kernconf)
                local make_target <const> = b:start_build()
                local function step_build()
                    local pipe <const>, pid <const>, target <const> =
                        make_target()
                    if not pipe then
                        log:trace("BUILD COMPLETE")
                        ws_send{command=msg.command, worktree=w, done=true}
                        return
                    end
                    log:trace("BUILD STEP: ", target)
                    handle_child(pipe, pid,
                        function(buf)
                            ws_send{command=msg.command, worktree=w,
                                target=target, output=buf}
                        end,
                        function(exit_type, exit_code)
                            -- TODO: handle other exit types
                            assert(exit_type == "exited")
                            if exit_code == 0 then
                                step_build()
                            end
                        end
                    )
                end
                step_build()
                return true
            end,
            [CMD_REPO_DELETE] = function(msg)
                local opts <const> = msg.data
                local b <const> =
                    builder.new(opts.worktree, makeobjdirprefix, kernconf)
                local pipe <const>, pid <const> =
                    b:delete_build(opts.pkg_abi, opts.version)
                handle_child(pipe, pid,
                    function(buf)
                        ws_send{command=msg.command, worktree=opts.worktree,
                            pkg_abi=opts.pkg_abi, version=opts.version,
                            output=buf}
                    end,
                    function(exit_type, exit_code)
                        -- TODO: handle other exit types
                        assert(exit_type == "exited")
                        ws_send{command=msg.command, worktree=opts.worktree,
                            pkg_abi=opts.pkg_abi, version=opts.version,
                            exit_code=exit_code}
                    end
                )
                return true
            end,
        }
        local ws_thread <const> = coroutine.create(function(event)
            local buf = ""
            repeat
                local payload <const>, opcode <const>, flags <const>,
                    consumed <const> = ws.receive(io.stdin)
                if opcode == ws.WS_OP_CLOSE then
                    break
                elseif opcode == ws.WS_OP_PING then
                    ws.send(output, payload, ws.WS_OP_PONG, ws.WS_FL_FIN)
                elseif opcode == ws.WS_OP_TEXT then
                    if payload then
                        buf = buf .. payload
                    end
                    if flags & ws.WS_FL_FIN ~= 0 then
                        local parser <const> = ucl.parser()
                        local ok <const>, err <const> = parser:parse_string(buf, "json")
                        buf = ""
                        if not ok then
                            log:error("parser error: ", err)
                            ws.send(output, "internal server error", ws.WS_OP_CLOSE, ws.WS_FL_FIN)
                            break
                        end
                        local msg <const> = parser:get_object()
                        if not msg.command then
                            log:error("invalid message: ", ucl.to_json({msg}))
                            ws.send(output, "invalid request", ws.WS_OP_CLOSE, ws.WS_FL_FIN)
                            break
                        end
                        local handler <const> = handlers[msg.command]
                        if not handler then
                            log:warn("unhandled message: ", ucl.to_json({msg}))
                        elseif not handler(msg) then
                            break
                        end
                    end
                else
                    log:warn("unhandled op: ", opcode)
                end
                -- Yield once we have consumed all the data for this event.
                if consumed >= event.data then
                    event = coroutine.yield()
                else
                    event.data = event.data - consumed
                end
            until false
        end)
        changelist = {
            {
                ident = io.stdin:fileno(),
                filter = kqueue.EVFILT_READ,
                flags = kqueue.EV_ADD,
                fflags = 0,
                data = 0,
                udata = ws_thread
            }
        }
        while coroutine.status(ws_thread) ~= "dead" do
            local event <const> = assert(kq:kevent(changelist))
            changelist = nil
            local ok <const>, err <const>, code <const> =
                coroutine.resume(event.udata, event)
            if not ok then
                log:error(err, code and (" (%d)"):format(code))
                log:debug(ucl.to_json(event))
            end
        end
        log:trace("websocket closed")
        kq:close()
        for thread in pairs(threads) do
            assert(coroutine.close(thread))
        end
    end
    log:trace("switching connection to websocket protocol")
    return { headers=headers, status=101, reason="Switching Protocols", body=ws_main }
end)

server:run(httpd.DEBUG)

-- vim: set et sw=4:
